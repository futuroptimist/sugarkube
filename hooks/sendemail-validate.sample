#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Customize the checks according to your needs. This sample applies each patch,
# scans it for secrets, and then runs the repository automation suite before
# sending mail.

validate_cover_letter () {
file="$1"
# cover letters are free-form; ensure the file at least exists and is readable
[ -r "$file" ]
}

register_cleanup () {
cmd=$1
if [ -n "$SEND_EMAIL_VALIDATE_CLEANUP" ]; then
SEND_EMAIL_VALIDATE_CLEANUP="$SEND_EMAIL_VALIDATE_CLEANUP; $cmd"
else
SEND_EMAIL_VALIDATE_CLEANUP="$cmd"
fi
trap "$SEND_EMAIL_VALIDATE_CLEANUP" EXIT
}

prepare_secret_scanner () {
if [ "${SEND_EMAIL_VALIDATE_SCANNER_STATUS+set}" = set ]; then
return "$SEND_EMAIL_VALIDATE_SCANNER_STATUS"
fi

SEND_EMAIL_VALIDATE_SCANNER_STATUS=1
scanner_file="./scripts/scan-secrets.py"

if [ ! -f "$scanner_file" ]; then
echo "sendemail-validate: warning: scripts/scan-secrets.py missing; skipping secret scan" >&2
return "$SEND_EMAIL_VALIDATE_SCANNER_STATUS"
fi

if ! SEND_EMAIL_VALIDATE_SCANNER_TMP=$(mktemp --tmpdir sendemail-validate.scan.XXXXXX 2>/dev/null); then
echo "sendemail-validate: error: failed to create temporary scanner" >&2
SEND_EMAIL_VALIDATE_SCANNER_STATUS=2
return "$SEND_EMAIL_VALIDATE_SCANNER_STATUS"
fi

if ! cp "$scanner_file" "$SEND_EMAIL_VALIDATE_SCANNER_TMP"; then
echo "sendemail-validate: error: failed to copy scanner" >&2
rm -f "$SEND_EMAIL_VALIDATE_SCANNER_TMP"
SEND_EMAIL_VALIDATE_SCANNER_STATUS=2
return "$SEND_EMAIL_VALIDATE_SCANNER_STATUS"
fi

chmod +x "$SEND_EMAIL_VALIDATE_SCANNER_TMP" 2>/dev/null || true
register_cleanup 'rm -f "$SEND_EMAIL_VALIDATE_SCANNER_TMP"'

SEND_EMAIL_VALIDATE_SCANNER_INTERPRETER=
if [ -x "$scanner_file" ]; then
SEND_EMAIL_VALIDATE_SCANNER_STATUS=0
else
if command -v python3 >/dev/null 2>&1; then
SEND_EMAIL_VALIDATE_SCANNER_INTERPRETER=python3
SEND_EMAIL_VALIDATE_SCANNER_STATUS=0
elif command -v python >/dev/null 2>&1; then
SEND_EMAIL_VALIDATE_SCANNER_INTERPRETER=python
SEND_EMAIL_VALIDATE_SCANNER_STATUS=0
else
echo "sendemail-validate: warning: no Python interpreter found; skipping secret scan" >&2
fi
fi

return "$SEND_EMAIL_VALIDATE_SCANNER_STATUS"
}

run_secret_scan () {
file="$1"
prepare_secret_scanner
status=$?
case $status in
0)
if [ -n "$SEND_EMAIL_VALIDATE_SCANNER_INTERPRETER" ]; then
if ! "$SEND_EMAIL_VALIDATE_SCANNER_INTERPRETER" "$SEND_EMAIL_VALIDATE_SCANNER_TMP" < "$file"; then
echo "sendemail-validate: secret scan failed for $file" >&2
return 1
fi
else
if ! "$SEND_EMAIL_VALIDATE_SCANNER_TMP" < "$file"; then
echo "sendemail-validate: secret scan failed for $file" >&2
return 1
fi
fi
;;
1)
return 0
;;
*)
return 1
;;
esac
}

validate_patch () {
file="$1"
# Scan the patch diff for secrets before sending it downstream.
if ! run_secret_scan "$file"; then
return 1
fi

# Ensure that the patch applies without conflicts.
git am -3 "$file"
}

validate_series () {
# Run repository automation once all patches apply. Regression coverage:
# tests/test_sendemail_validate_hook.py keeps this hook aligned with scripts/checks.sh.
if [ -x "./scripts/checks.sh" ]; then
./scripts/checks.sh || return
else
echo "sendemail-validate: warning: scripts/checks.sh missing; skipping repo checks" >&2
fi
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
        remote=$(git config --default origin --get sendemail.validateRemote) &&
        ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
        worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
        git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
        git config --replace-all sendemail.validateWorktree "$worktree"
else
        worktree=$(git config --get sendemail.validateWorktree)
fi || {
        echo "sendemail-validate: error: failed to prepare worktree" >&2
        exit 1
}

unset GIT_DIR GIT_WORK_TREE

input_file="$1"
case "$input_file" in
/*)
absolute_file="$input_file"
;;
*)
dirname_result=$(dirname "$input_file") || exit 1
absolute_dir=$(cd "$dirname_result" && (pwd -P 2>/dev/null || pwd)) || exit 1
absolute_file="$absolute_dir/$(basename "$input_file")"
;;
esac

cd "$worktree" &&

if grep -q "^diff --git " "$absolute_file"
then
        validate_patch "$absolute_file"
else
        validate_cover_letter "$absolute_file"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
git config --unset-all sendemail.validateWorktree &&
register_cleanup 'git worktree remove -ff "$worktree"' &&
validate_series
fi
